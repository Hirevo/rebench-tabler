use std::cmp::Ordering;
use std::path::Path;
use std::str::FromStr;

use anyhow::bail;
use clap::{ArgAction, Parser, ValueEnum};
use colored::Colorize;
use prettytable::format::consts::FORMAT_NO_LINESEP_WITH_TITLE;
use prettytable::format::Alignment;
use prettytable::Cell;
use prettytable::Row;
use prettytable::Table;

use crate::rebench::CandidateDataset;

mod rebench;

#[derive(Debug, Clone, PartialEq, ValueEnum)]
enum AnalysisMode {
    /// Analyze results based on the absolute time difference, relative to the baseline.
    Difference,
    /// Analyze results based on the speedup ratio, relative to the baseline.
    Speedup,
    /// Analyze results based on the absolute fastest runtime among all candidates.
    Fastest,
}

impl FromStr for AnalysisMode {
    type Err = anyhow::Error;
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "difference" => Ok(Self::Difference),
            "speedup" => Ok(Self::Speedup),
            "fastest" => Ok(Self::Fastest),
            _ => {
                bail!("expected `difference` or `speedup`, got `{input}`");
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Parser)]
#[command(about, author, version)]
struct Opts {
    /// Sets the kind of analysis to be performed with the benchmark data
    #[arg(long, short)]
    mode: AnalysisMode,
    /// Sets the threshold value (relative to the baseline) to signal an improvement or a regression (ignored if `--mode fastest`)
    #[arg(long, short, default_value = "0")]
    threshold: f64,
    /// The names to use for each dataset.
    #[arg(long, action = ArgAction::Set, num_args(0..))]
    names: Option<Vec<String>>,
    /// The dataset files, generated by ReBench
    datasets: Vec<String>,
}

#[allow(unused)]
fn compile_stats(vals: &[f64]) -> ((f64, f64), (f64, f64)) {
    let avg = vals.iter().sum::<f64>() / (vals.len() as f64);
    let dev = if vals.len() > 1 {
        let numerator = vals
            .iter()
            .copied()
            .map(|val| (val - avg).powi(2))
            .sum::<f64>();
        let denominator = (vals.len() - 1) as f64;

        (numerator / denominator).sqrt()
    } else {
        0.0
    };

    let min = vals
        .iter()
        .copied()
        .min_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal))
        .unwrap();
    let max = vals
        .iter()
        .copied()
        .max_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal))
        .unwrap();

    ((avg, dev), (min, max))
}

fn compute_difference((avg1, dev1): (f64, f64), (avg2, dev2): (f64, f64)) -> (f64, f64) {
    let avg = avg1 - avg2;
    let dev = (dev1.powi(2) + dev2.powi(2)).sqrt();
    (avg, dev)
}

fn compute_speedup((avg1, dev1): (f64, f64), (avg2, dev2): (f64, f64)) -> (f64, f64) {
    let avg = avg2 / avg1;
    let dev = avg * ((dev1 / avg1).powi(2) + (dev2 / avg2).powi(2)).sqrt();
    (avg, dev)
}

fn compute_average(values: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {
    let mut sum = 0.0;
    let mut stddev_sum = 0.0;
    let mut min = f64::INFINITY;
    let mut max = f64::NEG_INFINITY;
    for (value, stddev) in values.iter() {
        sum += value;
        stddev_sum += stddev * stddev;
        min = value.min(min);
        max = value.max(max);
    }
    let avg = sum / values.len() as f64;
    let stddev = (stddev_sum / values.len() as f64).sqrt();
    ((avg, stddev / (values.len() as f64).sqrt()), (min, max))
}

fn main() -> anyhow::Result<()> {
    let opts = Opts::parse();

    anyhow::ensure!(
        opts.names
            .as_ref()
            .map_or(true, |names| names.len() == opts.datasets.len()),
        "invalid number of dataset names"
    );

    let datasets: Vec<_> = opts
        .datasets
        .iter()
        .map(|path| CandidateDataset::from_file(&path))
        .collect::<anyhow::Result<_>>()?;

    let names: Vec<String> = opts.names.unwrap_or_else(|| {
        opts.datasets
            .iter()
            .map(|it| {
                Path::new(it)
                    .file_stem()
                    .map_or_else(|| it.clone(), |it| it.to_string_lossy().into_owned())
            })
            .collect()
    });

    let mut table = Table::new();
    table.set_format(*FORMAT_NO_LINESEP_WITH_TITLE);

    table.set_titles(Row::new(
        std::iter::once(Cell::new("Benchmark"))
            .chain(names.iter().map(|name| Cell::new(name.as_str())))
            .collect(),
    ));

    let [base, others @ ..] = datasets.as_slice() else {
        bail!("at least one dataset must be passed");
    };

    let mut values: Vec<Vec<(f64, f64)>> = others
        .iter()
        .map(|_| Vec::with_capacity(base.len()))
        .collect();

    for (bench, base_vals) in base.iter() {
        let mut cells = Vec::with_capacity(opts.datasets.len() + 1);
        cells.push(Cell::new(bench.bold().to_string().as_str()));

        let ((base_avg, base_dev), (base_min, base_max)) = (
            (base_vals.mean(), base_vals.standard_deviation()),
            (base_vals.min(), base_vals.max()),
        );

        let base = format!(
            "{} ± {} ({}..{})",
            format!("{base_avg:.2} ms").bold(),
            format!("{base_dev:.2}").yellow().bold(),
            format!("{base_min:.2}").cyan().bold(),
            format!("{base_max:.2}").cyan().bold(),
        );
        cells.push(Cell::new(base.as_str()));

        let maybe_values = match opts.mode {
            AnalysisMode::Difference => others
                .iter()
                .map(|map| {
                    let vals = map.get(bench)?;

                    let ((avg, dev), (min, max)) = (
                        (vals.mean(), vals.standard_deviation()),
                        (vals.min(), vals.max()),
                    );
                    let (diff_avg, diff_dev) = compute_difference((avg, dev), (base_avg, base_dev));
                    let (min, max) = (max - base_avg, min - base_avg);

                    let diff = format!(
                        "{} ± {} ({}..{})",
                        if (diff_avg / base_avg).abs() < opts.threshold {
                            format!("{diff_avg:.2} ms").bold()
                        } else if diff_avg > 1.0 {
                            format!("{diff_avg:.2} ms").red().bold()
                        } else {
                            format!("{diff_avg:.2} ms").green().bold()
                        },
                        format!("{diff_dev:.2}").yellow().bold(),
                        format!("{min:.2}").cyan().bold(),
                        format!("{max:.2}").cyan().bold(),
                    );
                    Some(Cell::new(diff.as_str()))
                })
                .collect::<Option<Vec<_>>>(),
            AnalysisMode::Speedup => others
                .iter()
                .enumerate()
                .map(|(idx, map)| {
                    let vals = map.get(bench)?;

                    let ((avg, dev), (min, max)) = (
                        (vals.mean(), vals.standard_deviation()),
                        (vals.min(), vals.max()),
                    );
                    let (speedup_avg, speedup_dev) =
                        compute_speedup((avg, dev), (base_avg, base_dev));

                    let (min, max) = (base_avg / max, base_avg / min);

                    values[idx].push((speedup_avg, speedup_dev));

                    let speedup = format!(
                        "{} ± {} ({}..{})",
                        if (speedup_avg - 1.0).abs() < opts.threshold {
                            format!("{speedup_avg:.2}x").bold()
                        } else if speedup_avg < 1.0 {
                            format!("{speedup_avg:.2}x").red().bold()
                        } else {
                            format!("{speedup_avg:.2}x").green().bold()
                        },
                        format!("{speedup_dev:.2}").yellow().bold(),
                        format!("{min:.2}").cyan().bold(),
                        format!("{max:.2}").cyan().bold(),
                    );
                    Some(Cell::new(speedup.as_str()))
                })
                .collect::<Option<Vec<_>>>(),
            AnalysisMode::Fastest => others
                .iter()
                .enumerate()
                .map(|(idx, map)| {
                    let vals = map.get(bench)?;

                    let ((avg, dev), (min, max)) = (
                        (vals.mean(), vals.standard_deviation()),
                        (vals.min(), vals.max()),
                    );
                    let (speedup_avg, speedup_dev) =
                        compute_speedup((avg, dev), (base_avg, base_dev));

                    values[idx].push((speedup_avg, speedup_dev));

                    let (min, max) = (base_avg / max, base_avg / min);

                    Some(((speedup_avg, speedup_dev), (min, max)))
                })
                .collect::<Option<Vec<_>>>()
                .map(|values| {
                    let (max_idx, _) = values
                        .iter()
                        .enumerate()
                        .max_by(|(_, ((a, b), _)), (_, ((c, d), _))| {
                            match a.partial_cmp(c).unwrap_or(Ordering::Equal) {
                                Ordering::Equal => d.partial_cmp(b).unwrap_or(Ordering::Equal),
                                ordering => ordering,
                            }
                        })
                        .unwrap();

                    values
                        .into_iter()
                        .enumerate()
                        .map(|(idx, ((speedup_avg, speedup_dev), (min, max)))| {
                            let speedup = format!(
                                "{} ± {} ({}..{})",
                                if speedup_avg < 1.0 {
                                    format!("{speedup_avg:.2}x").red().bold()
                                } else if idx == max_idx {
                                    format!("{speedup_avg:.2}x").green().bold()
                                } else {
                                    format!("{speedup_avg:.2}x").bold()
                                },
                                format!("{speedup_dev:.2}").yellow().bold(),
                                format!("{min:.2}").cyan().bold(),
                                format!("{max:.2}").cyan().bold(),
                            );
                            Cell::new(speedup.as_str())
                        })
                        .collect()
                }),
        };

        let Some(mut values) = maybe_values else {
            bail!("discarded bench due to missing data (benchmark: {bench})");
        };

        cells.append(&mut values);

        table.add_row(Row::new(cells));
    }

    match opts.mode {
        AnalysisMode::Speedup => {
            table.add_empty_row();
            table.add_row(Row::new(
                std::iter::once(Cell::new("Average Speedup".bold().to_string().as_str()))
                    .chain(std::iter::once(Cell::new_align(
                        "(baseline)".bold().to_string().as_str(),
                        Alignment::CENTER,
                    )))
                    .chain(values.into_iter().map(|values| {
                        let ((speedup_avg, speedup_dev), (min, max)) = compute_average(&values);
                        let speedup = format!(
                            "{} ± {} ({}..{})",
                            if (speedup_avg - 1.0).abs() < opts.threshold {
                                format!("{speedup_avg:.2}x").bold()
                            } else if speedup_avg < 1.0 {
                                format!("{speedup_avg:.2}x").red().bold()
                            } else {
                                format!("{speedup_avg:.2}x").green().bold()
                            },
                            format!("{speedup_dev:.2}").yellow().bold(),
                            format!("{min:.2}").cyan().bold(),
                            format!("{max:.2}").cyan().bold(),
                        );
                        Cell::new(speedup.as_str())
                    }))
                    .collect(),
            ));
        }
        AnalysisMode::Fastest => {
            let values: Vec<_> = values
                .into_iter()
                .map(|values| compute_average(&values))
                .collect();

            let (max_idx, _) = values
                .iter()
                .enumerate()
                .max_by(|(_, ((a, b), _)), (_, ((c, d), _))| {
                    match a.partial_cmp(c).unwrap_or(Ordering::Equal) {
                        Ordering::Equal => d.partial_cmp(b).unwrap_or(Ordering::Equal),
                        ordering => ordering,
                    }
                })
                .unwrap();

            table.add_empty_row();
            table.add_row(Row::new(
                std::iter::once(Cell::new("Average Speedup".bold().to_string().as_str()))
                    .chain(std::iter::once(Cell::new_align(
                        "(baseline)".bold().to_string().as_str(),
                        Alignment::CENTER,
                    )))
                    .chain(values.into_iter().enumerate().map(
                        |(idx, ((speedup_avg, speedup_dev), (min, max)))| {
                            let speedup = format!(
                                "{} ± {} ({}..{})",
                                if speedup_avg < 1.0 {
                                    format!("{:.2}x", speedup_avg).red().bold()
                                } else if idx == max_idx {
                                    format!("{:.2}x", speedup_avg).green().bold()
                                } else {
                                    format!("{:.2}x", speedup_avg).bold()
                                },
                                format!("{:.2}", speedup_dev).yellow().bold(),
                                format!("{:.2}", min).cyan().bold(),
                                format!("{:.2}", max).cyan().bold(),
                            );
                            Cell::new(speedup.as_str())
                        },
                    ))
                    .collect(),
            ));
        }
        _ => {}
    }

    table.printstd();

    Ok(())
}
